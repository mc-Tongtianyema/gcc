#include<bits/stdc++.h>
using namespace std;
int main(){
	/*动态规划
	线性：最大子段和，最长上升子序列，最长公共子序列
	模型：数字金字塔
	背包：01，完全
	
	动态规划：是一种对一类问题的最优解法。
	算法核心：存储（避免重复求解）
	算法步骤：分阶段、定状态：寻找状态转移方程
	
	最大字段和
	概念：连续的一串元素和且最大
	原问题：求n个元素中，最大的子段和
	DP：
	1.分阶段、定状态：以第i个元素结尾时，最大子段和
	2.状态转移方程：dp[i]=max(加入,不加入)=max(dp[i-1]+a[i],a[i])
	
	最长上升子序列
	概念：连续或非连续的一串递增元素 
	原问题：求n个元素中，最长上升子序列长度 
	DP：
	1.分阶段、定状态：以第i个元素结尾时，最长上升子序列长度
	2.状态转移方程：for(j:1-i-1)if(a[i]>a[j])dp[i]=max(dp[i],dp[j]+1)
	
	最长公共子序列
	概念：2个序列中，公共部分最长的长度（非连续） 
	DP：
	1.分阶段、定状态：以s1的第i个和以第s2的第j个结尾时，最长上升子序列长度 
	2.状态转移方程：if(s1[i-1]==s2[j-1])dp[i][j]=dp[i-1][j-1]+1
	                else dp[i][j]=max(dp[i-1][j],dp[i][j-1])
	
	数字金字塔 
	原问题：从1，1点出发，每次可以往下或往右下，走到最后一行停，最大的路径和 
	DP：
	1.分阶段、定状态：从1，1点出发，每次可以往下或往右下，走到i，j点停，最大的路径和
	2.状态转移方程：dp[i][j]=max(dp[i-1][j],dp[i-1][j-1])+a[i][j]
	
	背包：01，完全
	概念：n个物品，背包容量不超过m下，能带走的最大价值
	DP:
	1.分阶段、定状态：i个物品，背包容量不超过j下，能带走的最大价值
	2.状态转移方程*/ 
	//【01】
	for(n个物品){
		for(m容量，倒序){
			dp[j]=max(不装，装入)=max(dp[j],dp[j-v[i]]+w[i]) 
		}
	}
	//【完全】
	for(n个物品){
		for(m容量，正序){
			dp[j]=max(不装，装入)=max(dp[j],dp[j-v[i]]+w[i]) 
		}
	}
	return 0;
}
